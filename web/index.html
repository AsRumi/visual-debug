<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Visual Debug - 3D Space View</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, sans-serif;
        background: #000;
        color: #fff;
        overflow: hidden;
      }

      #canvas-container {
        width: 100vw;
        height: 100vh;
        position: relative;
      }

      #controls {
        position: absolute;
        bottom: 30px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 15px;
        align-items: center;
        padding: 20px 30px;
        background: rgba(10, 10, 20, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 100, 255, 0.2);
        border-radius: 15px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      }

      button {
        padding: 10px 20px;
        background: linear-gradient(
          135deg,
          rgba(100, 100, 255, 0.2) 0%,
          rgba(150, 100, 255, 0.2) 100%
        );
        color: #fff;
        border: 1px solid rgba(100, 100, 255, 0.3);
        border-radius: 8px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.3s;
        backdrop-filter: blur(5px);
      }

      button:hover {
        background: linear-gradient(
          135deg,
          rgba(100, 100, 255, 0.3) 0%,
          rgba(150, 100, 255, 0.3) 100%
        );
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(100, 100, 255, 0.3);
      }

      button:active {
        transform: translateY(0);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #speed-control {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-left: 20px;
        padding-left: 20px;
        border-left: 1px solid rgba(100, 100, 255, 0.2);
      }

      #speed-slider {
        width: 100px;
        height: 4px;
        -webkit-appearance: none;
        appearance: none;
        background: rgba(100, 100, 255, 0.2);
        outline: none;
        border-radius: 2px;
      }

      #speed-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: linear-gradient(135deg, #6464ff, #9664ff);
        cursor: pointer;
        border-radius: 50%;
        box-shadow: 0 2px 10px rgba(100, 100, 255, 0.5);
      }

      #info {
        position: absolute;
        top: 30px;
        left: 30px;
        padding: 20px;
        background: rgba(10, 10, 20, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 100, 255, 0.2);
        border-radius: 12px;
        font-family: "Consolas", "Courier New", monospace;
        max-width: 400px;
      }

      #operation-info {
        font-size: 16px;
        color: #9999ff;
        margin-bottom: 10px;
      }

      #array-info {
        font-size: 13px;
        color: rgba(255, 255, 255, 0.7);
        word-break: break-all;
      }

      #step-counter {
        position: absolute;
        top: 30px;
        right: 30px;
        padding: 15px 25px;
        background: rgba(10, 10, 20, 0.8);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(100, 100, 255, 0.2);
        border-radius: 12px;
        font-size: 18px;
        font-weight: 300;
        letter-spacing: 2px;
      }

      .step-label {
        color: rgba(255, 255, 255, 0.5);
        font-size: 12px;
        text-transform: uppercase;
        letter-spacing: 3px;
      }

      #loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
      }

      .loading-spinner {
        width: 50px;
        height: 50px;
        border: 3px solid rgba(100, 100, 255, 0.1);
        border-top: 3px solid #6464ff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      .loading-text {
        color: #9999ff;
        font-size: 14px;
        letter-spacing: 2px;
        text-transform: uppercase;
      }

      #connection-status {
        position: absolute;
        top: 30px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        background: rgba(10, 10, 20, 0.9);
        border: 1px solid rgba(255, 100, 100, 0.3);
        border-radius: 8px;
        color: #ff9999;
        font-size: 14px;
        display: none;
      }

      #connection-status.connected {
        border-color: rgba(100, 255, 100, 0.3);
        color: #99ff99;
      }

      #error-log {
        position: absolute;
        bottom: 120px;
        left: 30px;
        padding: 15px;
        background: rgba(255, 50, 50, 0.1);
        border: 1px solid rgba(255, 100, 100, 0.3);
        border-radius: 8px;
        color: #ff9999;
        font-size: 12px;
        font-family: monospace;
        max-width: 400px;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container"></div>

    <div id="connection-status">Connecting...</div>

    <div id="info">
      <div id="operation-info">Initializing space...</div>
      <div id="array-info"></div>
    </div>

    <div id="step-counter">
      <div class="step-label">Step</div>
      <div id="step-display">0 / 0</div>
    </div>

    <div id="controls">
      <button id="play-pause">▶ Play</button>
      <button id="step-forward">Step →</button>
      <button id="step-backward">← Step</button>
      <button id="reset">↺ Reset</button>

      <div id="speed-control">
        <label for="speed-slider">Speed:</label>
        <input
          type="range"
          id="speed-slider"
          min="0.5"
          max="5"
          step="0.5"
          value="1"
        />
        <span id="speed-value">1.0x</span>
      </div>
    </div>

    <div id="loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Initializing Universe</div>
    </div>

    <div id="error-log"></div>

    <!-- Socket.IO -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <!-- GSAP for smooth animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
      // Error logging
      function logError(message) {
        console.error(message);
        const errorLog = document.getElementById("error-log");
        errorLog.textContent = message;
        errorLog.style.display = "block";
        setTimeout(() => {
          errorLog.style.display = "none";
        }, 5000);
      }

      // Check if libraries loaded
      if (typeof THREE === "undefined") {
        logError("THREE.js failed to load. Check your internet connection.");
      }
      if (typeof gsap === "undefined") {
        logError("GSAP failed to load. Check your internet connection.");
      }
      if (typeof io === "undefined") {
        logError("Socket.IO failed to load. Check if server is running.");
      }

      // Global variables
      let scene, camera, renderer;
      let arrayElements = [];
      let operations = [];
      let currentStep = 0;
      let isPlaying = false;
      let animationSpeed = 1;
      let currentArray = [];
      let originalArray = [];
      let socket;

      // Three.js setup
      function initThreeJS() {
        try {
          // Scene
          scene = new THREE.Scene();
          scene.fog = new THREE.Fog(0x000000, 100, 500);

          // Camera
          camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 15, 30);
          camera.lookAt(0, 0, 0);

          // Renderer
          renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          renderer.shadowMap.enabled = true;
          renderer.shadowMap.type = THREE.PCFSoftShadowMap;
          document
            .getElementById("canvas-container")
            .appendChild(renderer.domElement);

          // Lighting
          const ambientLight = new THREE.AmbientLight(0x404080, 0.5);
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0x9999ff, 0.5);
          directionalLight.position.set(10, 20, 10);
          directionalLight.castShadow = true;
          scene.add(directionalLight);

          // Add stars
          createStarField();

          // Add subtle grid
          createGrid();

          // Start render loop
          animate();

          // Hide loading
          setTimeout(() => {
            document.getElementById("loading").style.display = "none";
          }, 1000);

          console.log("Three.js initialized successfully");
        } catch (error) {
          logError("Failed to initialize Three.js: " + error.message);
        }
      }

      function createStarField() {
        const geometry = new THREE.BufferGeometry();
        const vertices = [];
        const colors = [];

        for (let i = 0; i < 2000; i++) {
          vertices.push(
            (Math.random() - 0.5) * 500,
            (Math.random() - 0.5) * 500,
            (Math.random() - 0.5) * 500
          );

          const color = new THREE.Color();
          color.setHSL(0.6, 0.2, 0.5 + Math.random() * 0.5);
          colors.push(color.r, color.g, color.b);
        }

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(vertices, 3)
        );
        geometry.setAttribute(
          "color",
          new THREE.Float32BufferAttribute(colors, 3)
        );

        const material = new THREE.PointsMaterial({
          size: 0.5,
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
        });

        const stars = new THREE.Points(geometry, material);
        scene.add(stars);

        // Animate stars slowly
        function animateStars() {
          stars.rotation.y += 0.0001;
          requestAnimationFrame(animateStars);
        }
        animateStars();
      }

      function createGrid() {
        const gridHelper = new THREE.GridHelper(40, 20, 0x2020ff, 0x101040);
        gridHelper.position.y = -5;
        scene.add(gridHelper);
      }

      function createArrayElements(array) {
        // Clear existing elements
        arrayElements.forEach((el) => {
          if (el.group) {
            scene.remove(el.group);
            if (el.light) scene.remove(el.light);
            if (el.sphere) {
              el.sphere.geometry.dispose();
              el.sphere.material.dispose();
            }
            if (el.glowSphere) {
              el.glowSphere.geometry.dispose();
              el.glowSphere.material.dispose();
            }
          }
        });
        arrayElements = [];

        const spacing = 3.5;
        const startX = (-(array.length - 1) * spacing) / 2;
        const maxValue = Math.max(...array);

        array.forEach((value, index) => {
          // Group to hold sphere and value text
          const group = new THREE.Group();

          // Glowing sphere
          const geometry = new THREE.SphereGeometry(1, 32, 32);
          const material = new THREE.MeshPhongMaterial({
            color: 0x6464ff,
            emissive: 0x2020ff,
            emissiveIntensity: 0.2,
            transparent: true,
            opacity: 0.9,
          });
          const sphere = new THREE.Mesh(geometry, material);
          group.add(sphere);

          // Add glow effect
          const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
          const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x6464ff,
            transparent: true,
            opacity: 0.1,
          });
          const glowSphere = new THREE.Mesh(glowGeometry, glowMaterial);
          group.add(glowSphere);

          // Position based on value (height) and index (x position)
          const height = (value / maxValue) * 10;
          group.position.set(startX + index * spacing, height, 0);

          // Point light for each element
          const light = new THREE.PointLight(0x6464ff, 0.3, 10);
          light.position.copy(group.position);
          scene.add(light);

          scene.add(group);

          arrayElements.push({
            group,
            sphere,
            glowSphere,
            light,
            value,
            index,
            originalIndex: index,
            material,
          });
        });

        console.log(`Created ${arrayElements.length} array elements`);
      }

      function highlightElements(indices, color = 0xffff00) {
        indices.forEach((i) => {
          if (arrayElements[i]) {
            // Create pulse effect
            gsap.to(arrayElements[i].sphere.scale, {
              x: 1.3,
              y: 1.3,
              z: 1.3,
              duration: 0.2,
              yoyo: true,
              repeat: 1,
              ease: "power2.inOut",
            });

            // Change color temporarily
            arrayElements[i].material.emissive = new THREE.Color(color);
            arrayElements[i].material.emissiveIntensity = 0.5;

            // Reset color after animation
            setTimeout(() => {
              arrayElements[i].material.emissive = new THREE.Color(0x2020ff);
              arrayElements[i].material.emissiveIntensity = 0.2;
            }, 400);
          }
        });
      }

      function swapElements(i, j) {
        if (arrayElements[i] && arrayElements[j]) {
          const el1 = arrayElements[i];
          const el2 = arrayElements[j];

          // Swap positions with arc animation
          const pos1 = { x: el1.group.position.x, y: el1.group.position.y };
          const pos2 = { x: el2.group.position.x, y: el2.group.position.y };

          // Create arc path for element 1
          gsap.to(el1.group.position, {
            x: pos2.x,
            duration: 0.8 / animationSpeed,
            ease: "power2.inOut",
          });

          gsap.to(el1.group.position, {
            y: pos1.y + 3,
            duration: 0.4 / animationSpeed,
            ease: "power2.out",
            yoyo: true,
            repeat: 1,
          });

          // Create arc path for element 2
          gsap.to(el2.group.position, {
            x: pos1.x,
            duration: 0.8 / animationSpeed,
            ease: "power2.inOut",
          });

          gsap.to(el2.group.position, {
            y: pos2.y - 3,
            duration: 0.4 / animationSpeed,
            ease: "power2.out",
            yoyo: true,
            repeat: 1,
          });

          // Update light positions
          gsap.to(el1.light.position, {
            x: pos2.x,
            duration: 0.8 / animationSpeed,
            ease: "power2.inOut",
          });

          gsap.to(el2.light.position, {
            x: pos1.x,
            duration: 0.8 / animationSpeed,
            ease: "power2.inOut",
          });

          // Swap in array
          [arrayElements[i], arrayElements[j]] = [
            arrayElements[j],
            arrayElements[i],
          ];
          [currentArray[i], currentArray[j]] = [
            currentArray[j],
            currentArray[i],
          ];

          // Highlight during swap
          el1.material.emissive = new THREE.Color(0xff6464);
          el2.material.emissive = new THREE.Color(0xff6464);
          el1.material.emissiveIntensity = 0.4;
          el2.material.emissiveIntensity = 0.4;

          setTimeout(() => {
            el1.material.emissive = new THREE.Color(0x2020ff);
            el2.material.emissive = new THREE.Color(0x2020ff);
            el1.material.emissiveIntensity = 0.2;
            el2.material.emissiveIntensity = 0.2;
          }, 800 / animationSpeed);
        }
      }

      function markSorted(indices) {
        indices.forEach((i) => {
          if (arrayElements[i]) {
            // Make element glow green
            arrayElements[i].material.color = new THREE.Color(0x40ff40);
            arrayElements[i].material.emissive = new THREE.Color(0x20ff20);
            arrayElements[i].material.emissiveIntensity = 0.3;

            // Pulse effect
            gsap.to(arrayElements[i].sphere.scale, {
              x: 1.2,
              y: 1.2,
              z: 1.2,
              duration: 0.3,
              yoyo: true,
              repeat: 1,
              ease: "power2.inOut",
            });
          }
        });
      }

      function animate() {
        requestAnimationFrame(animate);

        // Subtle camera movement
        camera.position.x = Math.sin(Date.now() * 0.0001) * 2;
        camera.position.y = 15 + Math.sin(Date.now() * 0.0002) * 1;
        camera.lookAt(0, 0, 0);

        // Render
        renderer.render(scene, camera);
      }

      // Control functions
      function executeOperation(op) {
        console.log("Executing operation:", op.type);
        switch (op.type) {
          case "compare":
            highlightElements(op.indices, 0xffff00);
            updateInfo(
              `Comparing elements at positions ${op.indices[0]} and ${op.indices[1]}`
            );
            break;
          case "swap":
            swapElements(op.indices[0], op.indices[1]);
            updateInfo(
              `Swapping elements at positions ${op.indices[0]} and ${op.indices[1]}`
            );
            break;
          case "sorted":
            markSorted(op.indices);
            updateInfo(
              `Element at position ${op.indices[0]} is now in its final position`
            );
            break;
          case "complete":
            arrayElements.forEach((el) => {
              el.material.color = new THREE.Color(0x40ff40);
              el.material.emissive = new THREE.Color(0x20ff20);
              el.material.emissiveIntensity = 0.3;
            });
            updateInfo("Sorting complete! ✨");
            break;
          case "init":
            currentArray = [...op.array];
            originalArray = [...op.array];
            createArrayElements(op.array);
            updateInfo("Array initialized");
            break;
        }
        updateArrayInfo();
        updateStepCounter();
      }

      function stepForward() {
        if (currentStep < operations.length) {
          executeOperation(operations[currentStep]);
          currentStep++;
        }
      }

      function stepBackward() {
        if (currentStep > 0) {
          reset();
          const targetStep = currentStep - 1;
          for (let i = 0; i < targetStep; i++) {
            executeOperation(operations[i]);
          }
          currentStep = targetStep;
        }
      }

      function reset() {
        currentStep = 0;
        isPlaying = false;
        document.getElementById("play-pause").innerHTML = "▶ Play";

        if (originalArray.length > 0) {
          currentArray = [...originalArray];
          createArrayElements(originalArray);
          updateInfo("Reset to initial state");
          updateArrayInfo();
          updateStepCounter();
        }
      }

      function play() {
        if (!isPlaying || currentStep >= operations.length) {
          isPlaying = false;
          document.getElementById("play-pause").innerHTML = "▶ Play";
          return;
        }

        stepForward();
        setTimeout(() => play(), 1000 / animationSpeed);
      }

      function updateInfo(message) {
        document.getElementById("operation-info").textContent = message;
      }

      function updateArrayInfo() {
        document.getElementById(
          "array-info"
        ).textContent = `Array: [${currentArray.join(", ")}]`;
      }

      function updateStepCounter() {
        document.getElementById(
          "step-display"
        ).textContent = `${currentStep} / ${operations.length}`;
      }

      // Event listeners
      document.getElementById("play-pause").addEventListener("click", () => {
        isPlaying = !isPlaying;
        document.getElementById("play-pause").innerHTML = isPlaying
          ? "⏸ Pause"
          : "▶ Play";
        if (isPlaying) play();
      });

      document
        .getElementById("step-forward")
        .addEventListener("click", stepForward);
      document
        .getElementById("step-backward")
        .addEventListener("click", stepBackward);
      document.getElementById("reset").addEventListener("click", reset);

      document.getElementById("speed-slider").addEventListener("input", (e) => {
        animationSpeed = parseFloat(e.target.value);
        document.getElementById("speed-value").textContent =
          animationSpeed.toFixed(1) + "x";
      });

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // Socket.io connection
      function initSocket() {
        const statusDiv = document.getElementById("connection-status");
        statusDiv.style.display = "block";
        statusDiv.textContent = "Connecting to server...";

        try {
          socket = io();

          socket.on("connect", () => {
            console.log("Connected to visualization server");
            statusDiv.textContent = "Connected ✓";
            statusDiv.classList.add("connected");
            setTimeout(() => {
              statusDiv.style.display = "none";
            }, 2000);

            socket.emit("ready");
          });

          socket.on("connect_error", (error) => {
            console.error("Connection error:", error);
            statusDiv.textContent =
              "Connection failed. Check if server is running.";
            statusDiv.classList.remove("connected");
            logError(
              "Failed to connect to server. Make sure the extension is running."
            );
          });

          socket.on("disconnect", () => {
            console.log("Disconnected from server");
            statusDiv.style.display = "block";
            statusDiv.textContent = "Disconnected";
            statusDiv.classList.remove("connected");
          });

          socket.on("initialize", (data) => {
            console.log("Initializing with data:", data);
            currentArray = [...data.array];
            originalArray = [...data.array];
            createArrayElements(data.array);
            updateInfo(`Ready to visualize ${data.algorithm}`);
            updateArrayInfo();
            updateStepCounter();
          });

          socket.on("operations", (ops) => {
            console.log(`Received ${ops.length} operations`);
            operations = ops;
            currentStep = 0;

            // Initialize array from first operation
            if (ops.length > 0 && ops[0].type === "init" && ops[0].array) {
              currentArray = [...ops[0].array];
              originalArray = [...ops[0].array];
              createArrayElements(ops[0].array);
            }

            updateStepCounter();
            updateInfo("Operations loaded. Ready to visualize!");
          });

          socket.on("operation", (op) => {
            console.log("Received single operation:", op.type);
            operations.push(op);
            updateStepCounter();
          });

          socket.on("error", (error) => {
            console.error("Socket error:", error);
            logError("Socket error: " + error);
          });
        } catch (error) {
          logError("Failed to initialize socket: " + error.message);
        }
      }

      // Initialize everything
      if (typeof THREE !== "undefined" && typeof gsap !== "undefined") {
        initThreeJS();
        if (typeof io !== "undefined") {
          initSocket();
        } else {
          logError("Socket.IO not loaded. Cannot connect to server.");
        }
      } else {
        logError(
          "Required libraries not loaded. Check your internet connection."
        );
      }
    </script>
  </body>
</html>
